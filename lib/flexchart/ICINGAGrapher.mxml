<?xml version="1.0" encoding="utf-8"?>

<!--

COPYRIGHT:
 
This software is Copyright (c) 2008 NETWAYS GmbH, Christian Doebler 
                               <support@netways.de>

(Except where explicitly superseded by other copyright notices)


LICENSE:

This work is made available to you under the terms of Version 2 of
the GNU General Public License. A copy of that license should have
been provided with this software, but in any event can be snarfed
from http://www.fsf.org.

This work is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 or visit their web page on the internet at
http://www.fsf.org.


CONTRIBUTION SUBMISSION POLICY:

(The following paragraph is not intended to limit the rights granted
to you to modify and distribute this software under the terms of
the GNU General Public License and is only of importance to you if
you choose to contribute your changes and enhancements to the
community by submitting them to NETWAYS GmbH.)

By intentionally submitting any modifications, corrections or
derivatives to this work, or any other work intended for use with
this Software, to NETWAYS GmbH, you confirm that
you are the copyright holder for those contributions and you grant
NETWAYS GmbH a nonexclusive, worldwide, irrevocable,
royalty-free, perpetual, license to use, copy, create derivative
works based on those contributions, and sublicense and distribute
those contributions and any derivatives thereof.

-->

<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="vertical"
	styleName="plain"
	creationComplete="init();">

	<mx:Script>
		<![CDATA[
			import mx.controls.TextArea;

			/*
			 * IMPORT OF EXTERNAL LIBRARIES
			 */

			// communication w/ javascript
			//import flash.events.*;
			import flash.external.ExternalInterface;

			// auto refresh
			import flash.utils.Timer;      
			import flash.events.TimerEvent;

			// charts
			import mx.charts.AreaChart;
			import mx.charts.BarChart;
			import mx.charts.ChartItem;
			import mx.charts.ColumnChart;
			import mx.charts.LineChart;
			import mx.charts.PieChart;

			// chart series
			import mx.charts.chartClasses.Series;
			import mx.charts.series.AreaSeries;
			import mx.charts.series.BarSeries;
			import mx.charts.series.ColumnSeries;
			import mx.charts.series.LineSeries;
			import mx.charts.series.PieSeries;			

			// chart axes
			import mx.charts.AxisRenderer;
			import mx.charts.DateTimeAxis;
			import mx.charts.LinearAxis;			

			// chart legends
			import mx.charts.Legend;
			import mx.charts.LegendItem;

			// chart strokes
			import mx.graphics.IStroke;
			import mx.graphics.Stroke;

			// collections for data storage and dynamic updates
			import mx.collections.ArrayCollection;

			// grids
			import mx.containers.Grid;
			import mx.containers.GridRow;
			import mx.containers.GridItem;

			// alert popups
 			import mx.controls.Alert;
 			import mx.controls.Text;

			// conversion of html-color codes into uints
			import mx.styles.StyleManager;

			// misc
			import mx.messaging.AbstractConsumer;
			import mx.containers.Panel;
			import mx.controls.Label;
			import mx.graphics.IFill;
			import mx.graphics.SolidColor;




			/*
			 * DECLARATION AND INITIALIZATION OF GLOBAL VARIABLES
			 */
			private var versionStr:String = "090416_1523";
			private var debug:int = 0;

			public var seriesHandle:AreaSeries;
			public var legendHandle:Legend;

			public var myXML:XML = new XML();
			public var myLoader:URLLoader;

			public var dataSource:ArrayCollection = new ArrayCollection(); 
			private var dataSourceLength:int = 0;

			private var alertPrefix:String = "";

			private var messageStart:String = "Loading ...";
			private var progressLen:int = 17;
			private var progressChar:String = "-";
			private var progressOffset:int = 0;
			private var progressOffsetStep:int = 1;
			private var progressText:Text = new Text();
			private var progressTimer:Timer;
			private var progressTimerDelay:int = 40;

			private var progressTimeout:int = 20;
			private var progressTimeoutMsg:String = "No data available.";

			private var loadingMessage:String = "";
			private var loadingMessageDefault:String = "Retrieved empty dataset!";
			private var loadingMessageAlert:int = 0;
			private var loadingMessageCurrent:int = 0;
			private var loadingMessageAlertRepeat:int = 0;

			private var queryParameters:Object = new Object();

			private var refreshInterval:int = 0;
			private var refreshMax:int = 1;
			private var refreshTimer:Timer;
			private var fadeInterval:int = 100;
			private var fadeEnd:Number = 0;
			private var fadeStep:Number = 0;
			private var fadeTimer:Timer;
			private var panelDrawn:Boolean = false;
			private var refreshLock:Boolean = false;

			private var alphaAll:Number = 1;

			private var updateURL:String = new String();
			private var xmlRequest:URLRequest;
			private var currentPanel:Panel = new Panel();
			private var startupPanel:Panel = new Panel();

			private var axisRenderers:Array = new Array();
			private var linearAxis:LinearAxis = new LinearAxis();
			private var verticalAxes:Array = new Array();

			private var legendScaleFactor:Number = 1.0;

			private var panelTitle:String = "";
			private var panelTitleStalled:String = "";

			private var interpolateValues:Boolean = false;

			private var tzOffset:int = 0;


			/*
			 * MAIN METHODS
			 */
			private function xmlLoaded(event:Event):void {
				myXML = XML(myLoader.data);
				var dataSourceChanged:Boolean = getDataSource();
				if (!panelDrawn) {
					if (dataSourceChanged) {
						drawCharts();
						panelDrawn = true;
						showPanel();
					} else {
						showLoadingMessage();
					}
				} else if (dataSourceChanged) {
					if (!refreshLock) {
						refreshLock = true;
						dataSource.refresh();
						resetLoadingMessageCounter();
						refreshLock = false;
					}
				} else if (!dataSourceChanged) {
					showLoadingMessage();
				}
			}




			public function init():void {
				drawDefaultPanel();
				ExternalInterface.addCallback("externalCommand", externalCommand);
				setTimeZoneOffset();
				getQueryParameters();
				if (!checkQueryParameters()) return;
				hidePanel();
				processQueryParameters();
				drawDefaultPanel();
				showVersion();
				setRefresh();
				getXMLDataNow();
				if (refreshInterval) {
					refreshTimer = new Timer(refreshInterval, refreshMax);
					refreshTimer.addEventListener("timer", getXMLData);
					refreshTimer.start();
				}
			}




			private function getXMLData (event:TimerEvent):void {
				if (panelDrawn && !refreshLock) {
					xmlRequest = new URLRequest(updateURL);
					myLoader = new URLLoader(xmlRequest);
					myLoader.addEventListener("complete", xmlLoaded);
				}				
			}



			private function getXMLDataNow ():void {
				xmlRequest = new URLRequest(updateURL);
				myLoader = new URLLoader(xmlRequest);
				myLoader.addEventListener("complete", xmlLoaded);	
				updateURL += "&update=1";					
			}



			/*
			 * CHART-RELATED METHODS
			 */
			private function drawDefaultPanel ():void {

				startupPanel.percentWidth = 100;
				startupPanel.percentHeight = 100;
				startupPanel.layout = "absolute";

				progressText.setStyle("fontSize", 18);
				progressText.setStyle("fontWeight", "bold");
				progressText.setStyle("horizontalCenter", "0");
				progressText.setStyle("verticalCenter", "0");

				progressText.htmlText = html_entity_decode(messageStart);

				progressLen--;

				var progressTimerRepeat:int = 0;
				if (progressTimeout > 0 && progressTimerDelay > 0) {
					progressTimerRepeat = (progressTimeout * 1000) / progressTimerDelay;
				}

				progressTimer = new Timer(progressTimerDelay, progressTimerRepeat);
				progressTimer.addEventListener("timer", updateProgressBar);
				progressTimer.addEventListener("timerComplete", stopProgressBar);
				progressTimer.start();

				startupPanel.addChild(progressText);
				addChild(startupPanel);

			}



			private function removeDefaultPanel ():void {
				removeAllChildren();
				progressTimer.stop();
			}



			public function updateProgressBar (event:TimerEvent):void {

				var progressStr:String = messageStart + "\n";

				for (var offset:int = 0; offset <= progressLen; offset++) {
					if (progressOffset != offset) {
						progressStr += " ";
					} else {
						progressStr += progressChar;
					}
				}

				progressText.text = html_entity_decode(progressStr);

				progressOffset += progressOffsetStep;
				if (progressOffset > progressLen) {
					progressOffset = progressLen;
					progressOffsetStep = -1;
				} else if (progressOffset < 0) {
					progressOffset = 0;
					progressOffsetStep = 1;
				}

			}



			private function stopProgressBar (event:TimerEvent):void {

				progressText.htmlText = html_entity_decode(progressTimeoutMsg);
				progressTimer.stop();

			}




			public function drawCharts():void {

				// init
				alertPrefix = (myXML.titles.panel.length()) ? "Panel '" + myXML.titles.panel + "' - " : "Unknown panel - ";

				for each(var currentChartXML:XML in myXML.charts.children()) {

					var graphList:Array = new Array();
					var currentSeries:Array = new Array();
					var currentChart;

					var chartType:String = currentChartXML.type.toString();

					switch (chartType) {

						case "column":
							currentChart = getColumnChartFromXML(currentChartXML);
							break;

						case "bar":
							currentChart = getBarChartFromXML(currentChartXML);
							break;

						case "area":
							currentChart = getAreaChartFromXML(currentChartXML);
							break;

						case "line":
							currentChart = getLineChartFromXML(currentChartXML);
							break;

						case "pie":
							currentChart = getPieChartFromXML(currentChartXML);
							break;

						default:
							Alert.show(alertPrefix + "Invalid chart type '" + chartType + "'!");
							continue;
							break;

					}


					for each(var currentSeriesXML:XML in currentChartXML.series.children()) {

						var alertSource:String = alertPrefix;
						var seriesName:String = "";
						var seriesNodeName:String = currentSeriesXML.name().toString();

						if (currentSeriesXML.name.length()) { 
							seriesName = currentSeriesXML.name;
							alertSource += "Graph '" + seriesName + "': ";
						} else {
							seriesName = seriesNodeName;
							alertSource += "XML node '" + seriesName + "': ";
						}

						// perform some pre-checks
						if (chartType != "pie") {
							if (!currentSeriesXML.xField.length()) {
								Alert.show(alertSource + "Missing 'xField'!");
								continue;
							}
							if (!currentSeriesXML.yField.length()) {
								Alert.show(alertSource + "Missing 'yField'!");
								continue;
							}
						} else {
							if (!currentSeriesXML.field.length()) {
								Alert.show(alertSource + "Missing 'field'!");
								continue;
							}
						}

						// get type of graph and call graph functions
						var seriesType:String = currentSeriesXML.type;

						switch (seriesType) {

							case "line":
								var currentLineSeries:LineSeries = getLineSeriesFromXML(currentSeriesXML);
								if (checkAxes(currentSeriesXML)) {
									axisRenderers.push(getAxisRendererFromXML(currentSeriesXML));
								}
								currentLineSeries.verticalAxis = verticalAxes[verticalAxes.length - 1];
								currentSeries.push(currentLineSeries);
								break;

							case "area":
								var currentAreaSeries:AreaSeries = getAreaSeriesFromXML(currentSeriesXML);
								if (checkAxes(currentSeriesXML)) {
									axisRenderers.push(getAxisRendererFromXML(currentSeriesXML));
								}
								currentAreaSeries.verticalAxis = verticalAxes[verticalAxes.length - 1];
								currentSeries.push(currentAreaSeries);
								break;

							case "column":
								var currentColumnSeries:ColumnSeries = getColumnSeriesFromXML(currentSeriesXML);
								if (checkAxes(currentSeriesXML)) {
									axisRenderers.push(getAxisRendererFromXML(currentSeriesXML));
								}
								currentColumnSeries.verticalAxis = verticalAxes[verticalAxes.length - 1];
								currentSeries.push(currentColumnSeries);
								break;

							case "bar":
								var currentBarSeries:BarSeries = getBarSeriesFromXML(currentSeriesXML);
								if (checkAxes(currentSeriesXML)) {
									axisRenderers.push(getAxisRendererFromXML(currentSeriesXML));
								}
								currentBarSeries.verticalAxis = verticalAxes[verticalAxes.length - 1];
								currentSeries.push(currentBarSeries);
								break;

							case "pie":
								var currentPieSeries:PiesSeries = getPieSeriesFromXML(currentSeriesXML);
								if (checkAxes(currentSeriesXML)) {
									axisRenderers.push(getAxisRendererFromXML(currentSeriesXML));
								}
								currentPieSeries.verticalAxis = verticalAxes[verticalAxes.length - 1];
								currentSeries.push(currentPieSeries);
								break;

							default:
								Alert.show(alertSource + "Unknown graph type '" + seriesType + "'!");
								continue;
								break;

						}			

					}


					// get axes
					if (currentChartXML.axes.horizontal.length()) {
						var horizontalAxis:DateTimeAxis = new DateTimeAxis();
						horizontalAxis.parseFunction = parseDate;
						if (currentChartXML.axes.horizontal.title.length()) {
							horizontalAxis.title = currentChartXML.axes.horizontal.title.toString();
						}
						currentChart.horizontalAxis = horizontalAxis;
					}
					if (currentChartXML.axes.vertical.length()) {
						var verticalAxisDummy:LinearAxis = new LinearAxis();
						var numRenderers:int = axisRenderers.length;
						if (numRenderers) {
							for (var x:int = 0; x < numRenderers; x++) {
								currentChart.verticalAxisRenderers.push(axisRenderers[x]);					
							}
							currentChart.verticalAxis = verticalAxisDummy;
						} else {
							if (currentChartXML.axes.vertical.title.length()) {
								verticalAxisDummy.title = currentChartXML.axes.vertical.title.toString();
							}
							currentChart.verticalAxis = verticalAxisDummy;
						}
					}

					currentChart.series = currentSeries;
					currentPanel.addChild(currentChart);


					// add legend
					if (currentChartXML.legend.length()) {

						var currentLegend:Legend = new Legend();
						var legendError:Boolean = false;

						if (currentChartXML.legend.labelPlacement) {
							var currentLabelPlacement:String = currentChartXML.legend.labelPlacement.toString();
							switch (currentLabelPlacement) {
								case "top":
								case "bottom":
								case "right":
								case "left":
									currentLegend.setStyle("labelPlacement", currentLabelPlacement);
									break;
								default:
									Alert.show(alertPrefix + "Legend: Invalid labelPlacement '" + currentLabelPlacement + "'!");
									legendError = true;
									break;
							}
						}

						if (currentChartXML.legend.direction && !legendError) {
							var currentDirectionString:String = currentChartXML.legend.direction.toString();
							switch (currentDirectionString) {
								case "vertical":
								case "horizontal":
									currentLegend.direction = currentDirectionString;
									break;
								default:
									Alert.show(alertPrefix + "Legend: Invalid direction '" + currentDirectionString + "'!");
									legendError = true;
									break;
							}
						}

						if (legendScaleFactor > 0.0 && legendScaleFactor < 1.0) {
							currentLegend.scaleX = legendScaleFactor;
							currentLegend.scaleY = legendScaleFactor;
						}

						if (!legendError) {
							currentLegend.dataProvider = currentChart;
							currentPanel.addChild(currentLegend);
						}
					}

//					drawLegend(currentChart);

				}


				if (myXML.panel.title.length()) {
					panelTitle = myXML.panel.title;
					panelTitleStalled = panelTitle + " - PAUSE";
					currentPanel.title = myXML.panel.title;
				}
				if (myXML.panel.layout.length()) {
					currentPanel.layout = myXML.panel.layout;
				}
				if (myXML.panel.width.length()) {
					currentPanel.width = parseInt(myXML.panel.width);
				}
				if (myXML.panel.height.length()) {
					currentPanel.height = parseInt(myXML.panel.height);
				}

				removeDefaultPanel();
				addChild(currentPanel);

			}




			/*
			 * CHART-RELATED METHODS - AXES
			 */
			private function checkAxes (currentSeriesXML:XML):Boolean {
				if (
					!currentSeriesXML.axes.length() ||
					currentSeriesXML.axes.vertical.caps == "" ||
					currentSeriesXML.axes.vertical.alpha == "" ||
					currentSeriesXML.axes.vertical.weight == ""
				) {
					return false;
				}
				return true;
			}




			private function getAxisRendererFromXML (currentSeriesXML:XML):AxisRenderer {

				// init
				var currentAR:AxisRenderer = new AxisRenderer();
				var currentVA:LinearAxis = new LinearAxis();
				var currentStroke:Stroke = new Stroke();

				var currentTitle:String = "";

				var numAxes:int = verticalAxes.length;

				if (currentSeriesXML.axes.vertical.title.length()) {
					currentTitle = currentSeriesXML.axes.vertical.title.toString();
					currentVA.title = currentTitle;
					currentTitle += ": "; 
				}

				currentStroke.color = StyleManager.getColorName(currentSeriesXML.color.toString());

				//currentVA.chartDataProvider = dataSource;

				if (currentSeriesXML.axes.vertical.weight.length()) {
					currentStroke.weight = parseInt(currentSeriesXML.axes.vertical.weight.toString());
				} 
				if (currentSeriesXML.axes.vertical.alpha.length()) {
					currentStroke.alpha = parseFloat(currentSeriesXML.axes.vertical.alpha.toString());
				}
				if (currentSeriesXML.axes.vertical.caps.length()) {
					var currentCaps:String = currentSeriesXML.axes.vertical.caps.toString();
					switch (currentCaps) {
						case "round":
						case "square":
						case "none":
							currentStroke.caps = currentCaps;
							break;
						default:
							Alert.show(alertPrefix + currentTitle + "Invalid axis caps '" + currentCaps + "'!");
							break;
					}
				}
				currentAR.setStyle("axisStroke", currentStroke);

				if (!(numAxes % 2)) {
					currentAR.placement = "left";
				} else {
					currentAR.placement = "right";
				}

				currentAR.axis = currentVA;
				verticalAxes.push(currentVA);

				return currentAR;

			}




			/*
			 * CHART-RELATED METHODS - CHARTS
			 */
			private function getColumnChartFromXML (currentChart:XML):ColumnChart {

				// init
				var currentColumnChart:ColumnChart = new ColumnChart();

				// set parameters
				if (currentChart.subType) {
					var subType:String = currentChart.subType.toString();
					switch(subType) {
						case "clustered":
						case "overlaid":
						case "stacked":
						case "100%":
							currentColumnChart.type = subType;
							break;
						default:
							Alert.show(alertPrefix + "ColumnChart: Invalid subtype '" + subType + "'!");
							return(new ColumnChart());
							break;
					}
				}
				if (currentChart.width) {
					if (currentChart.width.substr(-1, 1) == "%") {
						currentColumnChart.percentWidth = parseInt(currentChart.width.substr(0, currentChart.width.length - 1));
					} else {
						currentColumnChart.width = parseInt(currentChart.width);
					}
				}
				if (currentChart.height) {
					if (currentChart.height.substr(-1, 1) == "%") {
						currentColumnChart.percentHeight = parseInt(currentChart.height.substr(0, currentChart.height.length - 1));
					} else {
						currentColumnChart.height = parseInt(currentChart.height);
					}
				}
				if (parseInt(currentChart.showDataTips)) {
					currentColumnChart.showDataTips = true;
				}

				return currentColumnChart;

			}




			private function getBarChartFromXML (currentChart:XML):BarChart {

				// init
				var currentBarChart:BarChart = new BarChart();

				// set parameters
				if (currentChart.subType) {
					var subType:String = currentChart.subType.toString();
					switch(subType) {
						case "clustered":
						case "overlaid":
						case "stacked":
						case "100%":
							currentBarChart.type = subType;
							break;
						default:
							Alert.show(alertPrefix + "ColumnChart: Invalid subtype '" + subType + "'!");
							return(new BarChart());
							break;
					}
				}
				if (currentChart.width) {
					if (currentChart.width.substr(-1, 1) == "%") {
						currentBarChart.percentWidth = parseInt(currentChart.width.substr(0, currentChart.width.length - 1));
					} else {
						currentBarChart.width = parseInt(currentChart.width);
					}
				}
				if (currentChart.height) {
					if (currentChart.height.substr(-1, 1) == "%") {
						currentBarChart.percentHeight = parseInt(currentChart.height.substr(0, currentChart.height.length - 1));
					} else {
						currentBarChart.height = parseInt(currentChart.height);
					}
				}
				if (parseInt(currentChart.showDataTips)) {
					currentBarChart.showDataTips = true;
				}

				return currentBarChart;

			}




			private function getAreaChartFromXML (currentChart:XML):AreaChart {

				// init
				var currentAreaChart:AreaChart = new AreaChart();

				// set parameters
				if (currentChart.subType) {
					var subType:String = currentChart.subType.toString();
					switch(subType) {
						case "overlaid":
						case "stacked":
						case "100%":
							currentAreaChart.type = subType;
							break;
						default:
							Alert.show(alertPrefix + "AreaChart: Invalid subtype '" + subType + "'!");
							return(new AreaChart());
							break;
					}
				}
				if (currentChart.width) {
					if (currentChart.width.substr(-1, 1) == "%") {
						currentAreaChart.percentWidth = parseInt(currentChart.width.substr(0, currentChart.width.length - 1));
					} else {
						currentAreaChart.width = parseInt(currentChart.width);
					}
				}
				if (currentChart.height) {
					if (currentChart.height.substr(-1, 1) == "%") {
						currentAreaChart.percentHeight = parseInt(currentChart.height.substr(0, currentChart.height.length - 1));
					} else {
						currentAreaChart.height = parseInt(currentChart.height);
					}
				}
				if (parseInt(currentChart.showDataTips)) {
					currentAreaChart.showDataTips = true;
				}

				return currentAreaChart;

			}




			private function getLineChartFromXML (currentChart:XML):LineChart {

				// init
				var currentLineChart:LineChart = new LineChart();

				// set parameters
				if (currentChart.width) {
					if (currentChart.width.substr(-1, 1) == "%") {
						currentLineChart.percentWidth = parseInt(currentChart.width.substr(0, currentChart.width.length - 1));
					} else {
						currentLineChart.width = parseInt(currentChart.width);
					}
				}
				if (currentChart.height) {
					if (currentChart.height.substr(-1, 1) == "%") {
						currentLineChart.percentHeight = parseInt(currentChart.height.substr(0, currentChart.height.length - 1));
					} else {
						currentLineChart.height = parseInt(currentChart.height);
					}
				}
				if (parseInt(currentChart.showDataTips)) {
					currentLineChart.showDataTips = true;
				}

				return currentLineChart;

			}




			private function getPieChartFromXML (currentChart:XML):PieChart {

				// init
				var currentPieChart:PieChart = new PieChart();
				currentPieChart.dataProvider = dataSource;

				// set parameters
				if (currentChart.width) {
					if (currentChart.width.substr(-1, 1) == "%") {
						currentPieChart.percentWidth = parseInt(currentChart.width.substr(0, currentChart.width.length - 1));
					} else {
						currentPieChart.width = parseInt(currentChart.width);
					}
				}
				if (currentChart.height) {
					if (currentChart.height.substr(-1, 1) == "%") {
						currentPieChart.percentHeight = parseInt(currentChart.height.substr(0, currentChart.height.length - 1));
					} else {
						currentPieChart.height = parseInt(currentChart.height);
					}
				}
				if (parseInt(currentChart.showDataTips)) {
					currentPieChart.showDataTips = true;
				}

				return currentPieChart;

			}




			/*
			 * CHART-RELATED METHODS - SERIES
			 */
			private function getLineSeriesFromXML (currentGraph:XML):LineSeries {

				// init and set base data
				var currentLineSeries:LineSeries = new LineSeries();
				var stroke:Stroke = new Stroke();
				var strokeDefined:Boolean = false;
                currentLineSeries.dataProvider = dataSource;
				currentLineSeries.xField = currentGraph.xField;
				currentLineSeries.yField = currentGraph.yField;

				// set name
				if (currentGraph.name) {
					currentLineSeries.displayName = currentGraph.name;
				}

				// set style
				if (currentGraph.form) {
					currentLineSeries.setStyle("form", currentGraph.form);
				}
				if (currentGraph.alpha) {
					currentLineSeries.alpha = currentGraph.alpha;
				}
				if (currentGraph.weight) {
					stroke.weight = parseInt(currentGraph.weight);
					if (!strokeDefined) {
						strokeDefined = true;
					}
				}
				if (currentGraph.color) {
					stroke.color = StyleManager.getColorName(currentGraph.color.toString());
					if (!strokeDefined) {
						strokeDefined = true;
					}
				}
				if (currentGraph.alpha) {
					stroke.alpha = parseFloat(currentGraph.alpha);
					if (!strokeDefined) {
						strokeDefined = true;
					}
				}
				if (strokeDefined) {				
					currentLineSeries.setStyle("lineStroke", stroke);
				}

				// set interpolation
				currentLineSeries.interpolateValues = interpolateValues;

				return currentLineSeries;

			}



			private function getAreaSeriesFromXML (currentGraph:XML):AreaSeries {

				// init set base data 
				var currentAreaSeries:AreaSeries = new AreaSeries();
				currentAreaSeries.dataProvider = dataSource;
				currentAreaSeries.xField = currentGraph.xField;
				currentAreaSeries.yField = currentGraph.yField;

				// set name
				if (currentGraph.name) {
					currentAreaSeries.displayName = currentGraph.name;
				}

				// set style
				if (currentGraph.alpha) {
					currentAreaSeries.alpha = currentGraph.alpha;
				}
				if (currentGraph.color) {
					currentAreaSeries.setStyle("areaFill", StyleManager.getColorName(currentGraph.color.toString()));
				}
				if (currentGraph.form) {
					currentAreaSeries.setStyle("form", currentGraph.form);
				}
				if (currentGraph.stroke) {
					var stroke:Stroke = new Stroke();
					if (currentGraph.stroke.weight) {
						stroke.weight = parseInt(currentGraph.stroke.weight);
					}
					if (currentGraph.stroke.color) {
						stroke.color = StyleManager.getColorName(currentGraph.stroke.color.toString());
					}
					if (currentGraph.stroke.alpha) {
						stroke.alpha = parseFloat(currentGraph.stroke.alpha);
					}
					currentAreaSeries.setStyle("areaStroke", stroke);
				}

				return currentAreaSeries;

			}




			private function getColumnSeriesFromXML (currentGraph:XML):ColumnSeries {

				// init set base data 
				var currentColumnSeries:ColumnSeries = new ColumnSeries();
				currentColumnSeries.dataProvider = dataSource;
				currentColumnSeries.xField = currentGraph.xField;
				currentColumnSeries.yField = currentGraph.yField;

				// set name
				if (currentGraph.name) {
					currentColumnSeries.displayName = currentGraph.name;
				}

				// set style
				if (currentGraph.width) {
					currentColumnSeries.width = parseInt(currentGraph.width);
				}
				if (currentGraph.alpha) {
					currentColumnSeries.alpha = currentGraph.alpha;
				}
				if (currentGraph.color) {
					currentColumnSeries.setStyle("columnFill", StyleManager.getColorName(currentGraph.color.toString()));
				}
				if (currentGraph.stroke) {
					var stroke:Stroke = new Stroke();
					if (currentGraph.stroke.weight) {
						stroke.weight = parseInt(currentGraph.stroke.weight);
					}
					if (currentGraph.stroke.color) {
						stroke.color = StyleManager.getColorName(currentGraph.stroke.color.toString());
					}
					if (currentGraph.stroke.alpha) {
						stroke.alpha = parseFloat(currentGraph.stroke.alpha);
					}
					currentColumnSeries.setStyle("columnStroke", stroke);
				}

				return currentColumnSeries;

			}




			private function getBarSeriesFromXML (currentGraph:XML):BarSeries {

				// init set base data 
				var currentBarSeries:BarSeries = new BarSeries();
				currentBarSeries.dataProvider = dataSource;
				currentBarSeries.xField = currentGraph.xField;
				currentBarSeries.yField = currentGraph.yField;

				// set name
				if (currentGraph.name) {
					currentBarSeries.displayName = currentGraph.name;
				}

				// set style
				if (currentGraph.width) {
					currentBarSeries.width = parseInt(currentGraph.width);
				}
				if (currentGraph.alpha) {
					currentBarSeries.alpha = currentGraph.alpha;
				}
				if (currentGraph.color) {
					currentBarSeries.setStyle("columnFill", StyleManager.getColorName(currentGraph.color.toString()));
				}
				if (currentGraph.stroke) {
					var stroke:Stroke = new Stroke();
					if (currentGraph.stroke.weight) {
						stroke.weight = parseInt(currentGraph.stroke.weight);
					}
					if (currentGraph.stroke.color) {
						stroke.color = StyleManager.getColorName(currentGraph.stroke.color.toString());
					}
					if (currentGraph.stroke.alpha) {
						stroke.alpha = parseFloat(currentGraph.stroke.alpha);
					}
					currentBarSeries.setStyle("columnStroke", stroke);
				}

				return currentBarSeries;

			}




			private function getPieSeriesFromXML (currentGraph:XML):PieSeries {

				// init set base data 
				var currentPieSeries:PieSeries = new PieSeries();
				currentPieSeries.field = currentGraph.field;

				if (currentGraph.nameField) {
					currentPieSeries.nameField = currentGraph.nameField;
				}

				// set name
				if (currentGraph.name) {
					currentPieSeries.displayName = currentGraph.name;
				}

				// set style
				if (currentGraph.disableDropShadow) {
					if (parseInt(currentGraph.disableDropShadow)) {
						currentPieSeries.filters = new Array();
					}
				}
				if (currentGraph.labelPosition) {
					var labelPosition:String = currentGraph.labelPosition.toString();
					switch(labelPosition) {
						case "none":
						case "outside":
						case "callout":
						case "inside":
						case "insideWithCallout":
							currentPieSeries.setStyle("labelPosition", labelPosition);
							break;
						default:
							Alert.show(alertPrefix + "PieSeries: Invalid labelPosition '" + labelPosition + "'!");
							return(new PieSeries());
							break;
					}
				}
				if (currentGraph.stroke) {
					var stroke:Stroke = new Stroke();
					if (currentGraph.stroke.weight) {
						stroke.weight = parseInt(currentGraph.stroke.weight);
					}
					if (currentGraph.stroke.color) {
						stroke.color = StyleManager.getColorName(currentGraph.stroke.color.toString());
					}
					if (currentGraph.stroke.alpha) {
						stroke.alpha = parseFloat(currentGraph.stroke.alpha);
					}
					currentPieSeries.setStyle("stroke", stroke);
				}
				if (currentGraph.radialStroke) {
					var radialStroke:Stroke = new Stroke();
					if (currentGraph.radialStroke.weight) {
						radialStroke.weight = parseInt(currentGraph.radialStroke.weight);
					}
					if (currentGraph.radialStroke.color) {
						radialStroke.color = StyleManager.getColorName(currentGraph.radialStroke.color.toString());
					}
					if (currentGraph.radialStroke.alpha) {
						radialStroke.alpha = parseFloat(currentGraph.radialStroke.alpha);
					}
					currentPieSeries.setStyle("radialStroke", radialStroke);
				}
				if (currentGraph.calloutStroke) {
					var calloutStroke:Stroke = new Stroke();
					if (currentGraph.calloutStroke.weight) {
						calloutStroke.weight = parseInt(currentGraph.calloutStroke.weight);
					}
					if (currentGraph.calloutStroke.color) {
						calloutStroke.color = StyleManager.getColorName(currentGraph.calloutStroke.color.toString());
					}
					if (currentGraph.calloutStroke.alpha) {
						calloutStroke.alpha = parseFloat(currentGraph.calloutStroke.alpha);
					}
					currentPieSeries.setStyle("calloutStroke", calloutStroke);
				}


				return currentPieSeries;

			}




			/*
			 * CHART-RELATED METHODS - CUSTOM LEGENDS
			 */
			private function drawLegend (myChart):void {

				var myGrid:Grid = new Grid();

				// Use a counter for the series.
				var z:int = 0;

				var numRows:int;
				var rowSize:int = 4;
				if (myChart.series.length % rowSize == 0) {
					// The number of series is exactly divisible by the rowSize.
					numRows = Math.floor(myChart.series.length / rowSize);
				} else {
					// One extra row is needed if there is a remainder.
					numRows = Math.floor(myChart.series.length / rowSize) + 1;
				}

				for (var j:int = 0; j < numRows; j++) {

					var gr:GridRow = new GridRow();
					myGrid.addChild(gr);

					for (var k:int = 0; k < rowSize; k++) {

						// As long as the series counter is less than the number of series...
						if (z < myChart.series.length) {

							var gi:GridItem = new GridItem();
							gr.addChild(gi);

							var li:LegendItem = new LegendItem();

							// Apply the current series' displayName to the LegendItem's label.
							li.label = myChart.series[z].displayName;

							// Get the current series' fill.
							var sc:SolidColor = myChart.series[z].getStyle("fill");

							// Apply the current series' fill to the corresponding LegendItem.
							li.setStyle("fill", sc);

							// Apply other styles to make the LegendItems look uniform.
							li.setStyle("textIndent", 5);
							li.setStyle("labelPlacement", "left");
							li.setStyle("fontSize", 9);

							gi.setStyle("backgroundAlpha", "1");
							gi.setStyle("backgroundColor", sc.color);
							gi.width = 80;

							// Add the LegendItem to the GridItem.
							gi.addChild(li);

							// Increment any time a LegendItem is added.
							z++;

						}

					}

				}

				currentPanel.addChild(myGrid);

			}




			/*
			 * COMMUNICATION W/ JAVASCRIPT
			 */
/*
			if (ExternalInterface.available) {
				try {
					// add callback
					ExternalInterface.addCallback("sendToActionScript", receivedFromJavaScript);
					if (!checkJavaScriptReady()) {
						Alert.show("JavaScript is not ready, creating timer.\n");
						var readyTimer:Timer = new Timer(100, 0);
						readyTimer.addEventListener(TimerEvent.TIMER, timerHandler);
						readyTimer.start();
					}
				} catch (error:SecurityError) {
					Alert.show("A SecurityError occurred: " + error.message + "\n");
				} catch (error:Error) {
					Alert.show("An Error occurred: " + error.message + "\n");
				}
			} else {
				Alert.show("External interface is not available for this container.");
			}
*/




			public function externalCommand(request:String):void {

				// extract key and value
				var keyAndValue:Array = request.split("|");

				switch (keyAndValue[0]) {
					case "t":
						var value:Number = 1;
						if (keyAndValue.length > 1 || keyAndValue[1] != "") {
							value = parseFloat(keyAndValue[1]);
						}
						if (getStyle("backgroundAlpha") == 1) {
							/*
							fadeStep = -0.1;
							fadeEnd = 0.5;
							*/
							setStyle("backgroundAlpha", value);
							currentPanel.setStyle("backgroundAlpha", value);
						} else {
							/*
							fadeStep = 0.1;
							fadeEnd = 1;
							*/
							setStyle("backgroundAlpha", value);
							currentPanel.setStyle("backgroundAlpha", value);
						}
						//fadeTimer.stop();
						/*
						fadeTimer = new Timer(fadeInterval, 0);
						fadeTimer.addEventListener("timer", fadeMe);
						fadeTimer.start();
						*/
						break;
				}
			}




			private function checkJavaScriptReady():Boolean {
				var isReady:Boolean = ExternalInterface.call("isReady");
				return isReady;
			}




			private function timerHandler(event:TimerEvent):void {
				Alert.show("Checking JavaScript status...\n");
				var isReady:Boolean = checkJavaScriptReady();
				if (isReady) {
					Alert.show("JavaScript is ready.\n");
					Timer(event.target).stop();
				}
			}




			/*
			 * EFFECTS
			 */
			private function fadeMe ():void {
				var fadeVal:Number = getStyle("backgroundAlpha");
				fadeVal += fadeStep;
				if (fadeStep < 0 && fadeVal <= fadeEnd) {
					fadeVal = fadeEnd;
					fadeTimer.stop();
				} else if (fadeStep > 0 && fadeVal >= fadeEnd) {
					fadeVal = fadeEnd;
					fadeTimer.stop();
				}
				setStyle("backgroundAlpha", fadeVal);
				currentPanel.setStyle("backgroundAlpha", fadeVal);
			}




			/*
			 * PROCESSING OF DATA SOURCES
			 */
			private function getDataSource():Boolean {

				// init
				var dataSourceNew:ArrayCollection = new ArrayCollection(); 
				var nodeName:String = new String();
				var retVal:Boolean = false;

				// loop through XML sources and fill new data source
				for each(var rowXML:XML in myXML.data.children()) {

					var row:Object = new Object();

					for each (var col:XML in rowXML.children()) {
						nodeName = col.name().toString();
						if (nodeName == "pair") {
							row = objSetItem(row, col.attribute("key").toString(), col.attribute("value").toString());
						} else if (nodeName == "t") {
							var currentTime:int = col.valueOf() - tzOffset;
							row = objSetItem(row, col.name().toString(), currentTime.toString());
						} else {
							row = objSetItem(row, col.name().toString(), col.toString());
						}
					}

					dataSourceNew.addItem(row);

				}

				// refresh data source
				retVal = refreshDataSource(dataSourceNew);

				return retVal;

			}




			private function checkDataSource (dataSourceNew:ArrayCollection):Boolean {

				// return immediately if there are no datasets at all
				if (!dataSourceNew.length) {
					if (debug) {
						Alert.show('checkDataSource: !dataSourceNew.length');
					}
					return false;
				}

				// determine number of values stored in data source
				var dataSourceLengthCurrent:int = dataSourceNew.length - 1;
				if (!dataSourceLengthCurrent) {
					if (debug) {
						Alert.show('checkDataSource: !dataSourceLengthCurrent');
					}
					currentPanel.title = panelTitleStalled;
					return false;
				}

				// check whether length of data is close to a 'full' dataset
				if (!panelDrawn) {
					dataSourceLength = dataSourceLengthCurrent;
					if (!dataSourceLength) {
						if (debug) {
							Alert.show('checkDataSource: !dataSourceLength');
						}
						return false;
					}
				} else {
					if (dataSourceNew.length < dataSourceLength - 3) {
						if (debug) {
							Alert.show('checkDataSource: dataSourceNew.length < dataSourceLength - 3');
						}
						currentPanel.title = panelTitleStalled;
						return false;
					} else {
						currentPanel.title = panelTitle;
					}
				}

				// refresh length of data for checks in the future
				if (dataSourceLengthCurrent > dataSourceLength) {
					dataSourceLength = dataSourceLengthCurrent;
				}

				// check each dataset for sub data
				for each (var currentSet:Object in dataSourceNew) {
					if (objLength(currentSet) < 2 || objItemEmpty(currentSet, "t")) {
						return false;
					}
				}

				return true;

			}




			private function refreshDataSource (dataSourceNew:ArrayCollection):Boolean {

				// check data integrity
				var retVal:Boolean = checkDataSource(dataSourceNew);

				// if data check did not fail run final update
				if (retVal) {

					dataSource.removeAll();

					for each (var currentSet:Object in dataSourceNew) {
						dataSource.addItem(currentSet);
					}

				}

				return retVal;

			}




			public function parseDate (s:String):Date {
				var newDate:Date = new Date;
				newDate.setTime(int(s) * 1000);
				return newDate;
			}




			/*
			 * PRE-PROCESSING
			 */
			private function getQueryParameters ():void {

				// try to fetch query parameters by using mx.core.Application
				if (mx.core.Application.application.parameters) {
					queryParameters = mx.core.Application.application.parameters;
					for each (var value:String in queryParameters) {
						queryParameters = objModLength(queryParameters);
					}
				}

				// try to fetch from other sources, too
				var queryString:String = ExternalInterface.call("window.location.search.substring", 1);
				if (!queryString.length) return;

				// extract key-value pairs from second source
				var paramPairs:Array = queryString.split("&");
				if (!paramPairs.length) return;

				// if current collection of parameters is less than the amount of parameters
				// of the second source, check and populate if some parameter is missing
				if (objLength(queryParameters) < queryString.length) {

					// init for key-value assignments
					var currentKey:String = new String();
					var currentValue:String = new String();

					// loop through data of second source and populate data if neccessary
					for each(var paramPair:String in paramPairs) {

						var keyValueArr:Array = paramPair.split("=");
						currentKey = keyValueArr[0];
						currentValue = "";

						if (keyValueArr.length > 2) {
							keyValueArr.shift();
							currentValue = keyValueArr.join("=");
						} else {
							currentValue = keyValueArr[1];
						}

						if (!objItemIsset(queryParameters, currentKey)) {
							queryParameters = objSetItem(queryParameters, currentKey, currentValue);
						}

					}

				}

			}




			private function checkQueryParameters ():Boolean {
				if (
					objItemEmpty(queryParameters, "src") ||
					(!objItemEmpty(queryParameters, "sn") && objItemEmpty(queryParameters, "sid")) ||
					(objItemEmpty(queryParameters, "sn") && !objItemEmpty(queryParameters, "sid")) ||
					(objItemEmpty(queryParameters, "pid") && objItemEmpty(queryParameters, "host") && objItemEmpty(queryParameters, "service"))
				) {
					return false;
				}
				return true;
			}




			private function processQueryParameters ():void {

				// init
				var srcURLParameters:Array = new Array(
					"pid", "host", "service", "start", "end", "aggregate", "pm", "cd"
				);

				// set debugging
				if (!objItemEmpty(queryParameters, "_DEBUG_")) {
					debug = parseInt(queryParameters._DEBUG_);
				}

				// create update URL
				updateURL = queryParameters.src;

				for each (var currentParameter:String in srcURLParameters) {
					if (!objItemEmpty(queryParameters, currentParameter)) {
						updateURL += "&" + currentParameter + "=" + queryParameters[currentParameter];
					}
				}

				if (!objItemEmpty(queryParameters, "sn") && !objItemEmpty(queryParameters, "sid")) {
					updateURL += "&" + queryParameters.sn + "=" + queryParameters.sid;
				}

				// set startup message
				if (!objItemEmpty(queryParameters, "msgStart")) {
					messageStart = queryParameters.msgStart;
				}

				// set progress bar
				if (!objItemEmpty(queryParameters, "progLen")) {
					progressLen = parseInt(queryParameters.progLen);
				}
				if (!objItemEmpty(queryParameters, "progChar")) {
					progressChar += queryParameters.progChar;
				}
				if (!objItemEmpty(queryParameters, "progDelay")) {
					progressTimerDelay = parseInt(queryParameters.progDelay);
				}

				// set progress timeout
				if (!objItemEmpty(queryParameters, "progTimeout")) {
					progressTimeout = parseInt(queryParameters.progTimeout);
				}
				if (!objItemEmpty(queryParameters, "progTimeoutMsg")) {
					progressTimeoutMsg = queryParameters.progTimeoutMsg;
				}

				// set message and corresponding counter for lags during retrieval
				if (!objItemEmpty(queryParameters, "lMsgMax")) {
					loadingMessageAlert = parseInt(queryParameters.lMsgMax);
					loadingMessage = (!objItemEmpty(queryParameters, "lMsg")) ? queryParameters.lMsg : loadingMessageDefault;
				}

				// set message and corresponding counter for lags during retrieval
				if (!objItemEmpty(queryParameters, "lMsgRep")) {
					loadingMessageAlertRepeat = (!objItemEmpty(queryParameters, "lMsg")) ? parseInt(queryParameters.lMsgRep) : 0;
				}

				// set global transparency
				if (!objItemEmpty(queryParameters, "t")) {
					alphaAll = parseFloat(queryParameters.t);
				}

				// set background color of panel
				if (!objItemEmpty(queryParameters, "pBG")) {
					currentPanel.setStyle("borderColor", htmlToColor(queryParameters.pBG));
				}				

				// set color of chart canvas
				if (!objItemEmpty(queryParameters, "cBG")) {
					currentPanel.setStyle("backgroundColor", htmlToColor(queryParameters.cBG));
				}

				// set scale factor of legend
				if (!objItemEmpty(queryParameters, "pm")) {
					legendScaleFactor = parseFloat(queryParameters.pm);
				}

				// check for interpolation
				if (!objItemEmpty(queryParameters, "iv")) {
					interpolateValues = (queryParameters.iv == "1") ? true : false;
					if (debug && interpolateValues) {
						Alert.show('interpolateValues -> true');
					}
				}

			}




			private function setRefresh ():void {

				if (objItemEmpty(queryParameters, "refresh")) return;

				var paramRefreshInterval:int = 0;
				var queryRefresh:int = parseInt(queryParameters.refresh);

				if (queryRefresh > 0) {
					paramRefreshInterval = queryRefresh;
				}

				if (!paramRefreshInterval) return;

				refreshMax = 0;
				refreshInterval = paramRefreshInterval * 1000;

			}




			private function showPanel ():void {
				// set transparency
				currentPanel.setStyle("backgroundAlpha", alphaAll);
				setStyle("backgroundAlpha", alphaAll);
			}




			private function hidePanel ():void {
				// set transparency
				currentPanel.setStyle("backgroundAlpha", 0);
				setStyle("backgroundAlpha", 0);
			}




			private function initPanel ():void {
				hidePanel();
				setStyle("backgroundColor", 0xffffff);
			}




			private function htmlToColor (htmlCode:String):Number {
				if (htmlCode.substr(0, 1) != "#") {
					htmlCode = "#" + htmlCode;
				}
				return StyleManager.getColorName(htmlCode);
			}




			/*
			 * USER NOTIFICATION
			 */
			private function showLoadingMessage ():void {
				if (loadingMessageAlert) {
					if (
						loadingMessageCurrent &&
						!(loadingMessageCurrent % loadingMessageAlert) &&
						!(loadingMessageCurrent && !loadingMessageAlertRepeat) 
					) {
						Alert.show(loadingMessage);
					}
					loadingMessageCurrent++;
				}
			}




			private function resetLoadingMessageCounter ():void {
				if (loadingMessageCurrent) {
					loadingMessageCurrent = 0;
				}
			}




			/*
			 * PROCESSING OF OBJECTS
			 */
			private function objLength (obj:Object):int {
				return obj.OBJ_NUM_ITEMS;
			}

			private function objModLength (obj:Object, increment:Boolean = true):Object {
				if (obj.OBJ_NUM_ITEMS == undefined) {
					obj.OBJ_NUM_ITEMS = 0;
				}
				if (increment) {
					obj.OBJ_NUM_ITEMS++;
				} else {
					obj.OBJ_NUM_ITEMS--;
				}
				return obj;
			}

			private function objSetItem (obj:Object, key:String, value:Object):Object  {
				if (obj[key] == undefined) {
					obj = objModLength(obj);
				}
				obj[key] = value;
				return obj;
			};

			private function objRemoveItem (obj:Object, key:String):Object  {
				if (obj[key] != undefined) {
					delete(obj[key]);
					obj = objModLength(obj, false);
				}
				return obj;
			};

			private  function objItemEmpty (obj:Object, key:String):Boolean {
				if (!objItemIsset(obj, key)) {
					return true;
				}
				var value:String = obj[key].toString();
				if (value == "" || value == "0") {
					return true;
				}
				return false;
			}

			private function objItemIsset (obj:Object, key:String):Boolean {
				return (obj[key] == undefined) ? false : true;
			}

			private function objGetItems (obj:Object):Object {
				delete(obj.OBJ_NUM_ITEMS);
				return obj;
			}

			private function wrap (obj:Object, key:String, prefix:String = "", suffix:String = "", force:Boolean = false):String {
				var retVal:String = "";
				var value:String = "";
				if (objItemIsset(obj, key)) {
					value = obj[key].toString();
				}
				if (value != "" || force) {
					retVal = prefix + value + suffix;
				}
				return retVal;
			}




			/*
			 * MISC
			 */
			private function showVersion ():void {
				if (debug) {
					Alert.show(versionStr);
				}
			}

			private function setTimeZoneOffset ():void {
				var dateNow:Date = new Date();
				tzOffset = dateNow.getTimezoneOffset() * 60;
			}

			private function html_entity_decode (html:String):String {
				return new XMLDocument(html).firstChild.nodeValue;
			}

		]]>
	</mx:Script>

</mx:Application> 
